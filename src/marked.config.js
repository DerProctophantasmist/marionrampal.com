// Generated by CoffeeScript 2.5.1
(function() {
  var Config, EmbedUrl, ResourceFile, carouselScheme, genRenderer, lexer, marked, oldRenderer, options, parserFactory, renderer, sectionsScheme, shorthand;

  module.exports = 'markedConfig';

  Config = window.config;

  marked = require('marked');

  oldRenderer = new marked.Renderer();

  ResourceFile = require('./resourceFile');

  EmbedUrl = require('./resourceUrl').embedUrl;

  renderer = {
    link: function(href, title, text) {
      var res;
      console.log("marked defaults: ");
      console.log(marked.defaults);
      if (res = ResourceFile(href, title, text, false)) { //last param is embed=true/false
        return res.html;
      } else {
        return oldRenderer.link(href, title, text);
      }
    },
    // heading: (text, level,raw,slugger) ->
    //   if level > 3 then return oldRenderer.heading(text,level,raw,slugger)
    //   escapedText = text.toLowerCase().replace(/[^\w]+/g, '-')
    //   return '<h' + level + ' class="special-font" ><a name="' +
    //     escapedText +
    //     '" class="anchor" href="#' +
    //     escapedText +
    //     '"><span class="header-link"></span></a>' +
    //     text + '</h' + level + '>';
    image: function(href, title, text) {
      var res;
      if ((res = EmbedUrl(href) || (res = ResourceFile(href, title, text, true)))) {
        // if res.provider &&res.provider != text.toLowerCase() then console.error('embeding failed for: ' + href + 'service ('+text+') doesn\'t match the one in the url ('+res.provider+')')
        return res.html;
      } else {
        return '<img class="image centered half" src="' + href + '" alt="' + text + '" title="' + title + '" >';
      }
    },
    code: function(code, infostring, escaped) {
      var res;
      res = shorthand(infostring, code);
      if (res) {
        return res;
      } else {
        return oldRenderer.code(code, infostring, escaped);
      }
    }
  };

  
  //for rendering the markdown inside the carousel code block, we start from our default options,
  genRenderer = new marked.Renderer();

  genRenderer.link = renderer.link;

  genRenderer.image = renderer.image;

  genRenderer.code = renderer.code;

  console.log("genRenderer");

  options = {
    gfm: true,
    breaks: false,
    renderer: genRenderer
  };

  marked.setOptions(options);

  console.log(marked.defaults);

  lexer = new marked.Lexer(options);

  shorthand = function(heading, content) {
    var i, params, result, type;
    i = heading.indexOf(' ');
    if (i !== -1) {
      type = heading.substring(0, i);
      params = {};
      try {
        params = JSON.parse('{' + heading.substring(i + 1) + '}');
      } catch (error) {}
    } else {
      type = heading;
    }
    console.log("heading: " + heading);
    console.log(params);
    switch (type) {
      case 'carousel':
        result = lexer.lex(content);
        console.log("carousel content:");
        result = parserFactory(carouselScheme)(result);
        console.log(result);
        return result;
      case "figure":
        console.log(content);
        // result = marked.inlineLexer(content,[],options)
        result = marked(content, options);
        console.log(result);
        return result = `<figure left-aside class="clickable image half" mdfile="${params.mdfile}" >

${result}                        
        
<figcaption>${params.caption}</figurecaption>

</figure>          `;
      case "imagesLeft":
        console.log(content);
        // result = marked.inlineLexer(content,[],options)
        result = marked(content, options);
        console.log(result);
        return result = `<div style="margin: 0" class="force-float-images-left clearfix">

${result}                        
            
</div>            `;
      case 'sections':
        result = lexer.lex(content);
        console.log("sections content:");
        result = parserFactory(sectionsScheme)(result);
        console.log(result);
        return result;
      default:
        return false;
    }
  };

  carouselScheme = {
    list: function(body) {
      return '<div uib-carousel active="active" interval="website.getCarouselInterval()">  \n' + body + '  \n</div>  \n';
    },
    listItem: function(body, curIndex) {
      return '<div uib-slide index="' + curIndex + '" >  \n' + marked(body, options) + '  \n</div>  \n';
    }
  };

  sectionsScheme = {
    list: function(body) {
      return '<div uib-carousel active="active" interval="website.getCarouselInterval()">  \n' + body + '  \n</div>  \n';
    },
    listItem: function(body, curIndex) {
      return '<div uib-slide index="' + curIndex + '" >  \n' + marked(body, options) + '  \n</div>  \n';
    },
    image: function(href, title, text) {
      var section;
      section = {
        id: title
      };
      website.sections.data.push();
      return `<section ng-if="website.displaySection(section.id)"  id="\{{section.id}}" section="section" ng-class="'section-' + section.id" >            
    <x-page ng-repeat='page in section.pages' ng-include="page.template" ng-init="pageIndex = $index"></x-page>
</section>`;
    }
  };

  parserFactory = function(parserScheme) {
    var curIndex, next, parse, parseText, peek, tok, token, tokens, unknownToken;
    token = null;
    tokens = null;
    curIndex = 0;
    parse = function(src) {
      var out;
      tokens = src.reverse();
      out = '';
      while (next()) {
        out += tok();
      }
      return out;
    };
    
    // * Next Token
    next = function() {
      token = tokens.pop();
      return token;
    };
    
    //  Preview Next Token
    peek = function() {
      return tokens[tokens.length - 1] || 0;
    };
    // * Parse Text Tokens
    parseText = function() {
      var body;
      body = token.text;
      while (peek().type === 'text') {
        body += '\n' + next().text;
      }
      return body;
    };
    unknownToken = function() {
      var errMsg;
      errMsg = 'Token with "' + token.type + '" type was not found.';
      console.log(errMsg);
      return '';
    };
    // Parse Current Token
    tok = function() {
      var body, checked, loose, ordered, start, task;
      switch (token.type) {
        case 'space':
          return '';
        // when 'hr': 
        //   return renderer.hr();

          // when 'heading': 
        //   return renderer.heading(
        //     inline.output(token.text),
        //     token.depth,
        //     unescape(inlineText.output(token.text)),
        //     slugger);

          // when 'code': 
        //   return renderer.code(token.text,
        //     token.lang,
        //     token.escaped);

          // when 'table': 
        //   header = ''
        //   body = ''

          //   // header
        //   cell = '';
        //   for (i = 0; i < token.header.length; i++) 
        //     cell += renderer.tablecell(
        //       inline.output(token.header[i]),
        //       { header: true, align: token.align[i] 
        //     );

          //   header += renderer.tablerow(cell);

          //   for (i = 0; i < token.cells.length; i++) {
        //     row = token.cells[i];

          //     cell = '';
        //     for (j = 0; j < row.length; j++) {
        //       cell += renderer.tablecell(
        //         inline.output(row[j]),
        //         { header: false, align: token.align[j] 
        //       );

          //     body += renderer.tablerow(cell);

          //   return renderer.table(header, body);

          // when 'blockquote_start': 
        //   body = '';

          //   while (next().type !== 'blockquote_end') 
        //     body += tok();         

          //   return parserScheme.blockquote(body);
        case 'list_start':
          if (!parserScheme.list) {
            return unknownToken();
          }
          curIndex = 0;
          body = '';
          ordered = token.ordered;
          start = token.start;
          while (next().type !== 'list_end') {
            body += tok();
          }
          return parserScheme.list(body);
        case 'list_item_start':
          if (!parserScheme.listItem) {
            return unknownToken();
          }
          body = '';
          console.log('list item:');
          console.log(token);
          loose = token.loose;
          checked = token.checked;
          task = token.task;
          // if (token.task) 
          //   body += renderer.checkbox(checked);

            // while (next().type !== 'list_item_end') 
          //   body += !loose && token.type === 'text'
          //     ? parseText()
          //     : tok();
          while (next().type !== 'list_item_end') {
            body += !loose && token.type === 'text' ? parseText() : tok();
          }
          return parserScheme.listItem(body, curIndex++);
        default:
          
          // when 'html': 
          //   // TODO parse inline content if parameter markdown=1
          //   return renderer.html(token.text);

          // when 'paragraph': 
          //   return renderer.paragraph(inline.output(token.text));

          // when 'text': 
          //   return renderer.paragraph(parseText());
          return unknownToken();
      }
    };
    return parse;
  };

  require('angular').module('markedConfig', [require('angular-marked'), require('angular-ui-bootstrap'), require('./oEmbed'), require('./config'), require('./resource.file')]).config([
    'markedProvider',
    'EmbedUrl',
    'ResourceFile',
    function(markedProvider,
    EmbedUrl,
    ResourceFile) {
      console.log("marked defaults");
      console.log(marked.defaults);
      markedProvider.setOptions(marked.defaults);
      return markedProvider.setRenderer(marked.defaults.renderer);
    }
  ]).directive('carouselCtrl', function() {
    return {
      template: "<div ng-transclude></div>",
      transclude: true,
      scope: {},
      controller: [
        function() {
          this.active = 0;
        }
      ],
      controllerAs: 'cc',
      link: function(scope, element, attrs) {
        var elt, i, j, listitem, ref, results, slides;
        elt = element[0];
        slides = elt.querySelectorAll("div[uib-slide]");
        console.log(elt);
        console.log(slides);
        results = [];
        for (i = j = 0, ref = slides.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          listitem = slides[i];
          listitem.setAttribute("index", i);
          console.log("item" + i);
          results.push(console.log(listitem));
        }
        return results;
      }
    };
  });

}).call(this);

//# sourceMappingURL=marked.config.js.map
